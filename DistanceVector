#!/usr/bin/env python3
import sys
import copy

INF = 999

def read_input():
    routers = []
    topology = []
    updates = []

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return sorted(routers), topology, updates

def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost
    return graph

def initialize_tables(routers, graph):
    dist_table = {}
    next_hop = {}
    for r in routers:
        dist_table[r] = {}
        next_hop[r] = {}
        for dest in routers:
            if r == dest:
                dist_table[r][dest] = 0
                next_hop[r][dest] = r
            elif dest in graph[r]:
                dist_table[r][dest] = graph[r][dest]
                next_hop[r][dest] = dest
            else:
                dist_table[r][dest] = INF
                next_hop[r][dest] = "-"
    return dist_table, next_hop

def distance_vector_step(routers, graph, dist_table, next_hop):
    updated = False
    new_table = copy.deepcopy(dist_table)
    new_next = copy.deepcopy(next_hop)

    for r in routers:
        for neighbor in graph[r]:
            for dest in routers:
                if dest == r:
                    continue
                new_cost = graph[r][neighbor] + dist_table[neighbor][dest]
                if new_cost < new_table[r][dest]:
                    new_table[r][dest] = new_cost
                    new_next[r][dest] = neighbor
                    updated = True
    return new_table, new_next, updated

def apply_updates(graph, updates):
    for src, dst, cost in updates:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            graph.setdefault(src, {})[dst] = cost
            graph.setdefault(dst, {})[src] = cost

def print_distance_table(router, dist_table, t):
    print(f"Distance Table of router {router} at t={t}:")
    peers = sorted(dist_table.keys())
    print("     " + "    ".join(peers))
    for dest in peers:
        row = [f"{dist_table[src][dest] if dist_table[src][dest] != INF else 'INF'}" for src in peers]
        print(f"{dest}    " + "    ".join(row))
    print()

def print_routing_table(router, dist_table, next_hop):
    print(f"Routing Table of router {router}:")
    for dest in sorted(dist_table[router].keys()):
        if dest != router:
            nh = next_hop[router][dest]
            cost = dist_table[router][dest]
            print(f"{dest},{nh},{cost if cost != INF else 'INF'}")
    print()

if __name__ == "__main__":
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)
    dist_table, next_hop = initialize_tables(routers, graph)

    update_round = 0
    while True:
        t = 0
        converged = False
        while not converged:
            for r in routers:
                print_distance_table(r, dist_table, t)
            dist_table, next_hop, updated = distance_vector_step(routers, graph, dist_table, next_hop)
            if not updated:
                converged = True
            t += 1
        for r in routers:
            print_routing_table(r, dist_table, next_hop)

        if update_round < len(updates):
            apply_updates(graph, updates[update_round])
            dist_table, next_hop = initialize_tables(routers, graph)
            update_round += 1
        else:
            break
