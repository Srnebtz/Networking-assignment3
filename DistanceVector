#!/usr/bin/env python3
import sys

INF = float('inf')

class Router:
    def __init__(self, name):
        self.name = name
        self.neighbors = {}  # neighbor_name -> cost
        self.distance_table = {}  # dest -> { via -> cost }
        self.routing_table = {}  # dest -> (next_hop, cost)
        self.updated = False

    def initialize(self, routers):
        for dest in routers:
            self.distance_table[dest] = {}
            for via in routers:
                if dest == via:
                    if via == self.name:
                        self.distance_table[dest][via] = 0
                    elif via in self.neighbors:
                        self.distance_table[dest][via] = self.neighbors[via]
                    else:
                        self.distance_table[dest][via] = INF
                else:
                    self.distance_table[dest][via] = INF
        self.update_routing_table()

    def send_distance_vector(self):
        return {dest: self.routing_table[dest][1] for dest in self.routing_table}

    def receive_distance_vector(self, from_router, vector):
        updated = False
        for dest in vector:
            cost = vector[dest]
            new_cost = self.neighbors[from_router] + cost
            if new_cost < self.distance_table[dest].get(from_router, INF):
                self.distance_table[dest][from_router] = new_cost
                updated = True
        if updated:
            self.updated = True
            self.update_routing_table()

    def update_routing_table(self):
        for dest in self.distance_table:
            if dest == self.name:
                continue
            min_cost = INF
            next_hop = None
            for via in self.distance_table[dest]:
                if self.distance_table[dest][via] < min_cost:
                    min_cost = self.distance_table[dest][via]
                    next_hop = via
            if min_cost < INF:
                self.routing_table[dest] = (next_hop, min_cost)

    def print_distance_table(self, t):
        print(f"Distance Table of router {self.name} at t={t}:")
        via_list = sorted(self.distance_table[next(iter(self.distance_table))])
        print("     " + "  ".join(via_list))
        for dest in sorted(self.distance_table):
            if dest == self.name:
                continue
            row = dest
            for via in via_list:
                val = self.distance_table[dest].get(via, INF)
                row += "    " + (str(int(val)) if val != INF else "INF")
            print(row)
        print()

    def print_routing_table(self):
        print(f"Routing Table of router {self.name}:")
        for dest in sorted(self.routing_table):
            next_hop, cost = self.routing_table[dest]
            print(f"{dest},{next_hop},{int(cost)}")
        print()

def simulate(lines):
    routers = {}
    time_step = 0
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if line == "EOF":
            break
        if line.startswith("topology"):
            _, src, dst, cost = line.split()
            cost = int(cost)
            for node in (src, dst):
                if node not in routers:
                    routers[node] = Router(node)
            routers[src].neighbors[dst] = cost
            routers[dst].neighbors[src] = cost
            i += 1
        elif line.startswith("update"):
            break
        else:
            i += 1

    for router in routers.values():
        router.initialize(routers)

    print_tables(routers, time_step)

    converged = False
    while not converged:
        time_step += 1
        updates = []
        for r in routers:
            vector = routers[r].send_distance_vector()
            for neighbor in routers[r].neighbors:
                updates.append((neighbor, r, vector))
        for recv, sender, vector in updates:
            routers[recv].receive_distance_vector(sender, vector)
        for r in routers:
            routers[r].updated = False
        print_tables(routers, time_step)
        converged = all(not routers[r].updated for r in routers)

    for r in sorted(routers):
        routers[r].print_routing_table()

    # Handle dynamic link cost changes
    while i < len(lines):
        line = lines[i].strip()
        if line.startswith("update"):
            _, src, dst, cost = line.split()
            cost = int(cost)
            routers[src].neighbors[dst] = cost
            routers[dst].neighbors[src] = cost
            for router in routers.values():
                router.initialize(routers)
            time_step += 1
            converged = False
            while not converged:
                time_step += 1
                updates = []
                for r in routers:
                    vector = routers[r].send_distance_vector()
                    for neighbor in routers[r].neighbors:
                        updates.append((neighbor, r, vector))
                for recv, sender, vector in updates:
                    routers[recv].receive_distance_vector(sender, vector)
                for r in routers:
                    routers[r].updated = False
                print_tables(routers, time_step)
                converged = all(not routers[r].updated for r in routers)
            for r in sorted(routers):
                routers[r].print_routing_table()
        i += 1

def print_tables(routers, t):
    for r in sorted(routers):
        routers[r].print_distance_table(t)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        input_file = "sample_input.txt" 
    else:
        input_file = sys.argv[1]
    with open(input_file, 'r') as f:
        lines = f.readlines()
    simulate(lines)
