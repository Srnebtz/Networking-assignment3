#!/usr/bin/env python3
import sys

INF = 999

def read_input():
    routers = []
    topology = []
    updates = []

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return sorted(routers), topology, updates

def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost
    return graph

def initialize_distance_table(router, routers, graph):
    table = {}
    neighbors = sorted(graph[router].keys())
    for via in neighbors:
        table[via] = {}
        for dest in routers:
            if dest == router:
                table[via][dest] = 0
            elif dest == via:
                table[via][dest] = graph[router][via]
            else:
                table[via][dest] = INF
    return table

def compute_distance_vector(table, routers):
    dv = {}
    next_hop = {}
    for dest in routers:
        min_cost = INF
        via_min = None
        for via in sorted(table.keys()):
            cost = table[via].get(dest, INF)
            if cost < min_cost or (cost == min_cost and (via_min is None or via < via_min)):
                min_cost = cost
                via_min = via
        dv[dest] = min_cost
        next_hop[dest] = via_min
    return dv, next_hop

def print_distance_table(router_name, table, t, routers):
    print(f"Distance Table of router {router_name} at t={t}:")
    vias = sorted(table.keys())
    dests = sorted([d for d in routers if d != router_name])
    header = "     " + "    ".join(dests)
    print(header)
    for via in vias:
        row = f"{via}    "
        for dest in dests:
            val = table[via][dest]
            row += f"{val if val != INF else 'INF'}    "
        print(row.strip())
    print()

def print_routing_table(router_name, dv, next_hop):
    print(f"Routing Table of router {router_name}:")
    for dest in sorted(dv.keys()):
        if dest == router_name:
            continue
        hop = next_hop[dest]
        cost = dv[dest]
        print(f"{dest},{hop},{cost if cost != INF else 'INF'}")
    print()

def distance_vector_round(routers, graph, tables):
    updated = False
    new_tables = {}

    for router in routers:
        new_table = {}
        neighbors = sorted(graph[router].keys())

        for via in neighbors:
            new_table[via] = {}
            via_dv, _ = compute_distance_vector(tables[via], routers)

            for dest in routers:
                if dest == router:
                    new_table[via][dest] = 0
                elif dest == via:
                    new_table[via][dest] = graph[router][via]
                else:
                    cost_to_dest = via_dv.get(dest, INF)
                    if graph[router][via] == INF or cost_to_dest == INF:
                        new_table[via][dest] = INF
                    else:
                        new_table[via][dest] = graph[router][via] + cost_to_dest

        if new_table != tables[router]:
            updated = True
        new_tables[router] = new_table

    return new_tables, updated

def apply_updates(graph, update_edges):
    for src, dst, cost in update_edges:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            graph.setdefault(src, {})[dst] = cost
            graph.setdefault(dst, {})[src] = cost

def main():
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)

    tables = {router: initialize_distance_table(router, routers, graph) for router in routers}
    t = 0
    round_num = 0

    while True:
        converged = False
        while not converged:
            print(f"t={t}")
            for router in routers:
                print_distance_table(router, tables[router], t, routers)
            new_tables, converged = distance_vector_round(routers, graph, tables)
            converged = not converged
            tables = new_tables
            t += 1

        for router in routers:
            dv, nh = compute_distance_vector(tables[router], routers)
            print_routing_table(router, dv, nh)

        if round_num < len(updates):
            print(f"Processing Update {round_num + 1}")
            apply_updates(graph, updates[round_num])
            tables = {router: initialize_distance_table(router, routers, graph) for router in routers}
            round_num += 1
            t = 0
        else:
            break

if __name__ == "__main__":
    main()