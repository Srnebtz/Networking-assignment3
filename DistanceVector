#!/usr/bin/env python3
import sys

INF = 999

def read_input():
    routers = []
    topology = []
    updates = []

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return sorted(routers), topology, updates

def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost
    return graph

def initialize_distance_table(router, routers, graph):
    table = {}
    for neighbor in sorted(graph[router].keys()):
        table[neighbor] = {}
        for dest in routers:
            if dest == router:
                table[neighbor][dest] = 0
            elif dest == neighbor:
                table[neighbor][dest] = graph[router][neighbor]
            else:
                table[neighbor][dest] = INF
    return table

def compute_distance_vector(table, routers):
    dv = {}
    next_hop = {}
    for dest in routers:
        min_cost = INF
        min_via = None
        for via in sorted(table.keys()):
            cost = table[via].get(dest, INF)
            if cost < min_cost or (cost == min_cost and (min_via is None or via < min_via)):
                min_cost = cost
                min_via = via
        dv[dest] = min_cost
        next_hop[dest] = min_via
    return dv, next_hop

def print_distance_table(router_name, table, t):
    print(f"Distance Table of router {router_name} at t={t}:")
    vias = sorted(table.keys())
    destinations = sorted([d for d in next(iter(table.values())).keys() if d != router_name])
    header = "     " + "    ".join(destinations)
    print(header)
    for via in vias:
        row = f"{via}    "
        for dest in destinations:
            val = table[via][dest]
            row += f"{val if val != INF else 'INF'}    "
        print(row.strip())
    print()

def print_routing_table(router_name, dv, next_hop):
    print(f"Routing Table of router {router_name}:")
    for dest in sorted(dv.keys()):
        if dest == router_name:
            continue
        hop = next_hop[dest]
        cost = dv[dest]
        print(f"{dest},{hop},{cost if cost != INF else 'INF'}")
    print()

def distance_vector_round(routers, graph, tables):
    updated = False
    new_tables = {}

    for router in routers:
        table = tables[router]
        new_table = {via: dict(costs) for via, costs in table.items()}

        for neighbor in graph[router]:
            neighbor_table = tables[neighbor]
            dv_neighbor, _ = compute_distance_vector(neighbor_table, routers)

            for dest in routers:
                if dest == router:
                    continue
                cost_to_neighbor = graph[router][neighbor]
                new_cost = cost_to_neighbor + dv_neighbor.get(dest, INF)
                if neighbor not in new_table:
                    new_table[neighbor] = {}
                if dest not in new_table[neighbor] or new_cost < new_table[neighbor][dest]:
                    new_table[neighbor][dest] = new_cost
                    updated = True

        new_tables[router] = new_table

    return new_tables, updated

def apply_updates(graph, update_edges):
    for src, dst, cost in update_edges:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            graph.setdefault(src, {})[dst] = cost
            graph.setdefault(dst, {})[src] = cost

def main():
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)
    tables = {router: initialize_distance_table(router, routers, graph) for router in routers}
    t = 0
    round_index = 0

    while True:
        while True:
            for router in routers:
                print_distance_table(router, tables[router], t)
            new_tables, updated = distance_vector_round(routers, graph, tables)
            if not updated:
                break
            tables = new_tables
            t += 1

        for router in routers:
            dv, nh = compute_distance_vector(tables[router], routers)
            print_routing_table(router, dv, nh)

        if round_index < len(updates):
            apply_updates(graph, updates[round_index])
            tables = {router: initialize_distance_table(router, routers, graph) for router in routers}
            round_index += 1
            t += 1
        else:
            break

if __name__ == "__main__":
    main()

