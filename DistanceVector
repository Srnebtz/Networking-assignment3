#!/usr/bin/env python3
import sys

INF = 999

class Router:
    def __init__(self, name, all_routers):
        self.name = name
        self.neighbors = {}
        self.distance_table = {src: {dst: INF for dst in all_routers} for src in all_routers}
        self.distance_vector = {dst: INF for dst in all_routers}
        self.routing_table = {dst: None for dst in all_routers}
        self.distance_table[name][name] = 0
        self.distance_vector[name] = 0
        self.routing_table[name] = name

    def update_link(self, neighbor, cost):
        if cost == -1:
            self.neighbors.pop(neighbor, None)
        else:
            self.neighbors[neighbor] = cost
            self.distance_table[self.name][neighbor] = cost
            self.distance_vector[neighbor] = cost
            self.routing_table[neighbor] = neighbor

    def exchange(self, routers):
        changed = False
        for dest in self.distance_vector:
            if dest == self.name:
                continue
            min_cost = self.distance_vector[dest]
            min_next_hop = self.routing_table[dest]
            for neighbor in self.neighbors:
                neighbor_cost = self.neighbors[neighbor]
                neighbor_router = routers[neighbor]
                neighbor_to_dest = neighbor_router.distance_vector[dest]
                total_cost = neighbor_cost + neighbor_to_dest
                if total_cost < min_cost:
                    min_cost = total_cost
                    min_next_hop = neighbor
            if min_cost != self.distance_vector[dest]:
                self.distance_vector[dest] = min_cost
                self.routing_table[dest] = min_next_hop
                self.distance_table[self.name][dest] = min_cost
                changed = True
        return changed

    def print_distance_table(self, all_routers, t):
        print(f"Distance Table of router {self.name} at t={t}:")
        header = "     " + "    ".join(all_routers)
        print(header)
        for src in all_routers:
            row = f"{src}    " + "    ".join(
                str(self.distance_table[src][dst]) if self.distance_table[src][dst] != INF else "INF"
                for dst in all_routers
            )
            print(row)
        print()

    def print_routing_table(self):
        print(f"Routing Table of router {self.name}:")
        for dest in sorted(self.routing_table):
            next_hop = self.routing_table[dest]
            cost = self.distance_vector[dest]
            if next_hop is not None:
                print(f"{dest},{next_hop},{cost}")
        print()

def read_input():
    routers = []
    topology = []
    updates = []
    current = []
    section = "ROUTERS"
    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
        elif line == "UPDATE":
            if current:
                updates.append(current)
            current = []
            section = "UPDATE"
        elif line == "END":
            if current:
                updates.append(current)
            break
        elif section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current.append((parts[0], parts[1], int(parts[2])))
    return sorted(routers), topology, updates

def build_routers(router_names, topology):
    routers = {name: Router(name, router_names) for name in router_names}
    for src, dst, cost in topology:
        routers[src].update_link(dst, cost)
        routers[dst].update_link(src, cost)
    return routers

def apply_updates(routers, updates):
    for src, dst, cost in updates:
        routers[src].update_link(dst, cost)
        routers[dst].update_link(src, cost)

def simulate(routers, router_names):
    t = 0
    while True:
        changed = False
        for router in routers.values():
            router.print_distance_table(router_names, t)
        for router in routers.values():
            if router.exchange(routers):
                changed = True
        if not changed:
            break
        t += 1
    for router in routers.values():
        router.print_routing_table()

if __name__ == "__main__":
    router_names, topology, updates = read_input()
    routers = build_routers(router_names, topology)
    simulate(routers, router_names)
    for update in updates:
        apply_updates(routers, update)
        simulate(routers, router_names)
