#!/usr/bin/env python3
import sys

INF = 999

def read_input():
    routers = []
    topology = []
    updates = []

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return sorted(routers), topology, updates

def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost
    return graph

def initialize_distance_table(router, routers, graph):
    table = {}
    for dest in routers:
        if dest == router:
            continue
        table[dest] = {}
        for via in sorted(graph[router].keys()):
            if dest == via:
                table[dest][via] = graph[router][via]
            elif dest == router:
                table[dest][via] = 0
            else:
                table[dest][via] = INF
    return table

def compute_distance_vector(table, routers):
    dv = {}
    next_hop = {}
    for dest in sorted(table.keys()):
        min_cost = INF
        min_via = None
        for via in sorted(table[dest].keys()):
            cost = table[dest][via]
            if cost < min_cost or (cost == min_cost and (min_via is None or via < min_via)):
                min_cost = cost
                min_via = via
        dv[dest] = min_cost
        next_hop[dest] = min_via
    return dv, next_hop

def print_distance_table(router_name, table, t):
    print(f"Distance Table of router {router_name} at t={t}:")
    vias = sorted({via for dest in table for via in table[dest]})
    dests = sorted(table.keys())
    print("     " + "    ".join(vias))
    for dest in dests:
        row = f"{dest}    "
        for via in vias:
            val = table[dest].get(via, INF)
            row += f"{val if val != INF else 'INF'}    "
        print(row.strip())
    print()

def print_routing_table(router_name, dv, next_hop):
    print(f"Routing Table of router {router_name}:")
    for dest in sorted(dv.keys()):
        hop = next_hop[dest]
        cost = dv[dest]
        print(f"{dest},{hop},{cost if cost != INF else 'INF'}")
    print()

def distance_vector_round(routers, graph, tables):
    updated = False
    new_tables = {}

    for router in routers:
        table = tables[router]
        new_table = {dest: dict(via_costs) for dest, via_costs in table.items()}
        for neighbor in graph[router]:
            neighbor_dv, _ = compute_distance_vector(tables[neighbor], routers)
            for dest in sorted(router for router in routers if router != router):
                cost_to_neighbor = graph[router][neighbor]
                cost = cost_to_neighbor + neighbor_dv.get(dest, INF)
                if neighbor not in new_table.get(dest, {}):
                    new_table.setdefault(dest, {})[neighbor] = cost
                elif cost < new_table[dest][neighbor]:
                    new_table[dest][neighbor] = cost
                    updated = True
        new_tables[router] = new_table
    return new_tables, updated

def apply_updates(graph, update_edges):
    for src, dst, cost in update_edges:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            graph.setdefault(src, {})[dst] = cost
            graph.setdefault(dst, {})[src] = cost

def main():
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)

    tables = {router: initialize_distance_table(router, routers, graph) for router in routers}
    t = 0
    round_num = 0

    while True:
        while True:
            for router in routers:
                print_distance_table(router, tables[router], t)
            new_tables, updated = distance_vector_round(routers, graph, tables)
            if not updated:
                break
            tables = new_tables
            t += 1

        for router in routers:
            dv, nh = compute_distance_vector(tables[router], routers)
            print_routing_table(router, dv, nh)

        if round_num < len(updates):
            apply_updates(graph, updates[round_num])
            tables = {router: initialize_distance_table(router, routers, graph) for router in routers}
            round_num += 1
            t += 1
        else:
            break

if __name__ == "__main__":
    main()
