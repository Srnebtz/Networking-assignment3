import sys
import copy

INF = 999

def parse_input_file(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()

    routers = set()
    topology = {}
    updates = []

    section = 0
    for line in lines:
        line = line.strip()
        if not line:
            section += 1
            continue

        if section == 0:
            src, dest, cost = line.split()
            routers.add(src)
            routers.add(dest)
            topology.setdefault(src, {})[dest] = int(cost)
            topology.setdefault(dest, {})[src] = int(cost)
        else:
            t, src, dest, cost = line.split()
            updates.append((int(t), src, dest, int(cost)))
            routers.add(src)
            routers.add(dest)

    return sorted(routers), topology, updates

def init_distance_table(routers, topology):
    distance_tables = {}
    next_hops = {}
    for router in routers:
        table = {}
        hops = {}
        for dest in routers:
            table[dest] = {}
            hops[dest] = None
            for via in routers:
                table[dest][via] = INF
        table[router][router] = 0
        for neighbor in topology.get(router, {}):
            table[neighbor][neighbor] = topology[router][neighbor]
            hops[neighbor] = neighbor
        distance_tables[router] = table
        next_hops[router] = hops
    return distance_tables, next_hops

def print_distance_table(router, table, routers):
    print(f"Distance Table of router {router} at t={print_distance_table.time}:")
    print("     " + "    ".join(r for r in routers if r != router))
    for dest in routers:
        if dest == router:
            continue
        row = f"{dest}"
        for via in routers:
            if via == router:
                continue
            val = table[dest][via]
            row += f"    {val if val != INF else 'INF'}"
        print(row)
    print()
print_distance_table.time = 0

def print_routing_table(router, table, routers):
    print(f"Routing Table of router {router}:")
    for dest in sorted(routers):
        if dest == router:
            continue
        min_cost = INF
        next_hop = None
        for via in routers:
            if table[dest][via] < min_cost:
                min_cost = table[dest][via]
                next_hop = via
        if min_cost != INF and next_hop is not None:
            print(f"{dest},{next_hop},{min_cost}")
    print()

def update_tables(routers, tables):
    updated = False
    new_tables = copy.deepcopy(tables)
    for router in routers:
        for dest in routers:
            if dest == router:
                continue
            for via in routers:
                if via == router:
                    continue
                if tables[router][via][via] == INF:
                    continue
                cost = tables[router][via][via] + min(tables[via][dest].values())
                if cost < new_tables[router][dest][via]:
                    new_tables[router][dest][via] = cost
                    updated = True
    return new_tables, updated

def apply_update(topology, update):
    _, src, dest, cost = update
    if cost == -1:
        topology[src].pop(dest, None)
        topology[dest].pop(src, None)
    else:
        topology.setdefault(src, {})[dest] = cost
        topology.setdefault(dest, {})[src] = cost

def distance_vector(filename):
    routers, topology, updates = parse_input_file(filename)
    tables, _ = init_distance_table(routers, topology)

    t = 0
    while True:
        print_distance_table.time = t
        for router in routers:
            print_distance_table(router, tables[router], routers)

        tables, updated = update_tables(routers, tables)
        if not updated:
            break
        t += 1

    for router in routers:
        print_routing_table(router, tables[router], routers)

    current_topology = copy.deepcopy(topology)
    for update in updates:
        apply_update(current_topology, update)
        tables, _ = init_distance_table(routers, current_topology)
        t += 1
        print_distance_table.time = t
        while True:
            for router in routers:
                print_distance_table(router, tables[router], routers)
            tables, updated = update_tables(routers, tables)
            if not updated:
                break
            t += 1
        for router in routers:
            print_routing_table(router, tables[router], routers)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: python DistanceVector.py <input_file>")
        sys.exit(1)
    distance_vector(sys.argv[1])