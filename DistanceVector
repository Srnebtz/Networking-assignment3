#!/usr/bin/env python3
import sys

INF = float('inf')

def read_input():
    routers = []
    topology = []
    updates = [] 

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()

        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return routers, topology, updates


def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost 
    return graph

def initialize_distance_tables(routers, graph):
    distance_tables = {}
    for router in routers:
        table = {}
        for target in routers:
            if router == target:
                table[target] = (0, router)
            elif target in graph[router]:
                table[target] = (graph[router][target], target)
            else:
                table[target] = (INF, None)
        distance_tables[router] = table
    return distance_tables

def distance_vector_step(routers, graph, distance_tables):
    updated = False
    new_tables = {}

    for router in routers:
        current_table = distance_tables[router]
        new_table = current_table.copy()

        for neighbor in graph[router]:
            neighbor_table = distance_tables[neighbor]
            cost_to_neighbor = graph[router][neighbor]

            for dest in routers:
                if dest == router:
                    continue
                neighbor_cost_to_dest, _ = neighbor_table[dest]
                new_cost = cost_to_neighbor + neighbor_cost_to_dest

                if new_cost < new_table[dest][0]:
                    new_table[dest] = (new_cost, neighbor)
                    updated = True

        new_tables[router] = new_table

    return new_tables, updated

def apply_updates(graph, update_edges):
    for src, dst, cost in update_edges:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            if src not in graph:
                graph[src] = {}
            if dst not in graph:
                graph[dst] = {}
            graph[src][dst] = cost
            graph[dst][src] = cost



if __name__ == "__main__":
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)
    distance_tables = initialize_distance_tables(routers, graph)

    update_round = 0
    while True:
        round_num = 0
        converged = False

        while not converged:
            for router in sorted(routers):
                print(f"Distance Table of router {router} at t={round_num}:")
                dests = [d for d in sorted(routers) if d != router]
                print(" ".join(dests))
                print(" ".join("INF" if distance_tables[router][d][0] == INF else str(distance_tables[router][d][0]) for d in dests))
                print(" ".join(distance_tables[router][d][1] if distance_tables[router][d][1] else "INF" for d in dests))
                print()

            distance_tables, updated = distance_vector_step(routers, graph, distance_tables)
            if not updated:
                converged = True
            round_num += 1


        for router in sorted(routers):
            print(f"Routing Table of router {router}:")
            dests = [d for d in sorted(routers) if d != router]
            print(" ".join(dests))
            print(" ".join("INF" if distance_tables[router][d][0] == INF else str(distance_tables[router][d][0]) for d in dests))
            print(" ".join(distance_tables[router][d][1] if distance_tables[router][d][1] else "INF" for d in dests))
            print()
 

        if update_round < len(updates):
            apply_updates(graph, updates[update_round])
            distance_tables = initialize_distance_tables(routers, graph)
            update_round += 1
        else:
            break

