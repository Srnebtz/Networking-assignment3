#!/usr/bin/env python3
import sys

INF = 999

def read_input():
    routers = []
    topology = []
    updates = [] 

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return sorted(routers), topology, updates


def build_graph(routers, topology):
    graph = {r: {} for r in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost
    return graph


def initialize_tables(routers, graph):
    tables = {}
    for r in routers:
        table = {}
        for dst in routers:
            if r == dst:
                table[dst] = (0, r)
            elif dst in graph[r]:
                table[dst] = (graph[r][dst], dst)
            else:
                table[dst] = (INF, None)
        tables[r] = table
    return tables


def distance_vector_step(routers, graph, tables):
    updated = False
    new_tables = {}

    for r in routers:
        current = tables[r]
        new_table = current.copy()

        for neighbor in graph[r]:
            neighbor_table = tables[neighbor]
            to_neighbor = graph[r][neighbor]

            for dest in routers:
                if dest == r:
                    continue
                neighbor_cost, _ = neighbor_table[dest]
                new_cost = to_neighbor + neighbor_cost

                if new_cost < new_table[dest][0]:
                    new_table[dest] = (new_cost, neighbor)
                    updated = True

        new_tables[r] = new_table

    return new_tables, updated


def print_distance_tables(routers, tables, t):
    for r in routers:
        print(f"Distance Table of router {r} at t={t}:", flush=True)
        others = [d for d in routers if d != r]
        header = "     " + "    ".join(others)
        print(header, flush=True)

        for row in others:
            cost_row = []
            hop_row = []
            for col in others:
                cost, hop = tables[r][col]
                cost_str = str(cost) if cost != INF else "INF"
                hop_str = hop if hop else "INF"
                cost_row.append(cost_str)
                hop_row.append(hop_str)
            print(f"{row}    " + "    ".join(cost_row), flush=True)
        print(flush=True)


def print_routing_tables(routers, tables):
    for r in routers:
        print(f"Routing Table of router {r}:", flush=True)
        for dest in sorted(routers):
            if dest == r:
                continue
            cost, hop = tables[r][dest]
            cost_str = str(cost) if cost != INF else "INF"
            hop_str = hop if hop else "INF"
            print(f"{dest},{hop_str},{cost_str}", flush=True)
        print(flush=True)


def apply_updates(graph, update_list):
    for src, dst, cost in update_list:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            graph.setdefault(src, {})[dst] = cost
            graph.setdefault(dst, {})[src] = cost


if __name__ == "__main__":
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)
    tables = initialize_tables(routers, graph)

    for round_num, update in enumerate([None] + updates):
        t = 0
        converged = False
        while not converged:
            print_distance_tables(routers, tables, t)
            tables, changed = distance_vector_step(routers, graph, tables)
            if not changed:
                converged = True
            t += 1
        print_routing_tables(routers, tables)
        if update:
            apply_updates(graph, update)
            tables = initialize_tables(routers, graph)
