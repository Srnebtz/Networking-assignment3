#!/usr/bin/env python3
import sys

INF = float('inf')

def read_input():
    routers = []
    topology = []
    updates = [] 

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()

        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return routers, topology, updates

def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost 
    return graph

def initialize_distance_tables(routers, graph):
    distance_tables = {}
    for router in routers:
        table = {}
        for target in routers:
            if router == target:
                table[target] = (0, router)
            elif target in graph[router]:
                table[target] = (graph[router][target], target)
            else:
                table[target] = (INF, None)
        distance_tables[router] = table
    return distance_tables

def distance_vector_step(routers, graph, distance_tables):
    updated = False
    new_tables = {}

    for router in routers:
        current_table = distance_tables[router]
        new_table = current_table.copy()

        for neighbor in graph[router]:
            neighbor_table = distance_tables[neighbor]
            cost_to_neighbor = graph[router][neighbor]

            for dest in routers:
                if dest == router:
                    continue
                neighbor_cost_to_dest, _ = neighbor_table[dest]
                new_cost = cost_to_neighbor + neighbor_cost_to_dest

                if new_cost < new_table[dest][0]:
                    new_table[dest] = (new_cost, neighbor)
                    updated = True

        new_tables[router] = new_table

    return new_tables, updated

def apply_updates(graph, update_edges):
    for src, dst, cost in update_edges:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            if src not in graph:
                graph[src] = {}
            if dst not in graph:
                graph[dst] = {}
            graph[src][dst] = cost
            graph[dst][src] = cost

def print_distance_tables(round_num, routers, distance_tables):
    for router in sorted(routers):
        print(f"Distance Table of router {router} at t={round_num}:")
        dests = sorted([d for d in routers if d != router])
        print("     " + "    ".join(dests))
        for via in dests:
            row = [via]
            for dst in dests:
                if dst == via:
                    cost = distance_tables[router][dst][0]
                else:
                    if distance_tables[router][dst][1] == via:
                        cost = distance_tables[router][dst][0]
                    else:
                        cost = INF
                row.append("INF" if cost == INF else str(cost))
            print("    ".join(row))
        print()

def print_routing_tables(routers, distance_tables):
    for router in sorted(routers):
        print(f"Routing Table of router {router}:")
        dests = sorted([d for d in routers if d != router])
        for dst in dests:
            cost, via = distance_tables[router][dst]
            cost_str = "INF" if cost == INF else str(cost)
            via_str = via if via else "INF"
            print(f"{dst},{via_str},{cost_str}")
        print()

if __name__ == "__main__":
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)
    distance_tables = initialize_distance_tables(routers, graph)

    update_round = 0
    while True:
        round_num = 0
        converged = False

        while not converged:
            print_distance_tables(round_num, routers, distance_tables)
            distance_tables, updated = distance_vector_step(routers, graph, distance_tables)
            if not updated:
                converged = True
            round_num += 1

        print_routing_tables(routers, distance_tables)

        if update_round < len(updates):
            apply_updates(graph, updates[update_round])
            distance_tables = initialize_distance_tables(routers, graph)
            update_round += 1
        else:
            break
