#!/usr/bin/env python3
import sys

INF = float('inf')

def read_input():
    routers = []
    topology = []
    updates = [] 

    section = "ROUTERS"
    current_update = []

    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break

        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))

    return sorted(routers), topology, updates

def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost 
    return graph

def initialize_distance_tables(routers, graph):
    distance_tables = {}
    for router in routers:
        table = {}
        for target in routers:
            if router == target:
                table[target] = (0, router)
            elif target in graph[router]:
                table[target] = (graph[router][target], target)
            else:
                table[target] = (INF, None)
        distance_tables[router] = table
    return distance_tables

def distance_vector_step(routers, graph, distance_tables):
    updated = False
    new_tables = {}

    for router in routers:
        current_table = distance_tables[router]
        new_table = current_table.copy()

        for neighbor in graph[router]:
            neighbor_table = distance_tables[neighbor]
            cost_to_neighbor = graph[router][neighbor]

            for dest in routers:
                if dest == router:
                    continue
                neighbor_cost_to_dest, _ = neighbor_table[dest]
                new_cost = cost_to_neighbor + neighbor_cost_to_dest

                if new_cost < new_table[dest][0]:
                    new_table[dest] = (new_cost, neighbor)
                    updated = True

        new_tables[router] = new_table

    return new_tables, updated

def apply_updates(graph, update_edges):
    for src, dst, cost in update_edges:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            graph.setdefault(src, {})[dst] = cost
            graph.setdefault(dst, {})[src] = cost

def print_distance_tables(routers, distance_tables, t):
    for router in sorted(routers):
        dests = sorted([d for d in routers if d != router])
        print(f"Distance Table of router {router} at t={t}:")

        print(" ".join(dests))

        print(" ".join("INF" if distance_tables[router][d][0] == INF else str(distance_tables[router][d][0]) for d in dests))

        print(" ".join("INF" if distance_tables[router][d][1] is None else distance_tables[router][d][1] for d in dests))
        print() 



def print_routing_tables(routers, distance_tables):
    for router in sorted(routers):
        dests = sorted([d for d in routers if d != router])
        print(f"Routing Table of router {router}:")
        for d in dests:
            cost, via = distance_tables[router][d]
            cost_str = "INF" if cost == INF else str(cost)
            via_str = via if via else "INF"
            print(f"{d},{via_str},{cost_str}")
        print()



if __name__ == "__main__":
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)
    distance_tables = initialize_distance_tables(routers, graph)

    update_round = 0
    while True:
        t = 0
        converged = False
        while not converged:
            print_distance_tables(routers, distance_tables, t)
            distance_tables, updated = distance_vector_step(routers, graph, distance_tables)
            if not updated:
                converged = True
            t += 1

        print_routing_tables(routers, distance_tables)

        if update_round < len(updates):
            apply_updates(graph, updates[update_round])
            distance_tables = initialize_distance_tables(routers, graph)
            update_round += 1
        else:
            break
