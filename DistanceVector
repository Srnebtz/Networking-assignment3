#!/usr/bin/env python3
import sys

INF = 999999

def read_input():
    routers = []
    topology = []
    updates = []
    section = "ROUTERS"
    current_update = []
    for line in sys.stdin:
        line = line.strip()
        if line == "START":
            section = "TOPOLOGY"
            continue
        elif line == "UPDATE":
            if current_update:
                updates.append(current_update)
                current_update = []
            section = "UPDATE"
            continue
        elif line == "END":
            if current_update:
                updates.append(current_update)
            break
        if section == "ROUTERS":
            routers.append(line)
        elif section == "TOPOLOGY":
            parts = line.split()
            if len(parts) == 3:
                topology.append((parts[0], parts[1], int(parts[2])))
        elif section == "UPDATE":
            parts = line.split()
            if len(parts) == 3:
                current_update.append((parts[0], parts[1], int(parts[2])))
    return sorted(routers), topology, updates

def build_graph(routers, topology):
    graph = {router: {} for router in routers}
    for src, dst, cost in topology:
        graph[src][dst] = cost
        graph[dst][src] = cost
    return graph

def initialize_distance_table(router, routers, graph, prev_tables=None):
    table = {}
    neighbors = graph[router]
    for via in sorted(neighbors.keys()):
        table[via] = {}
        for dest in routers:
            if dest == router:
                table[via][dest] = 0
            elif dest == via:
                table[via][dest] = neighbors[via]
            else:
                if prev_tables:
                    dv_via, _ = compute_distance_vector(prev_tables[via], routers)
                    table[via][dest] = neighbors[via] + dv_via.get(dest, INF)
                else:
                    table[via][dest] = INF
    return table

def compute_distance_vector(table, routers):
    dv = {}
    next_hop = {}
    for dest in routers:
        min_cost = INF
        best_via = None
        for via in sorted(table.keys()):
            cost = table[via].get(dest, INF)
            if cost < min_cost or (cost == min_cost and (best_via is None or via < best_via)):
                min_cost = cost
                best_via = via
        dv[dest] = min_cost
        next_hop[dest] = best_via
    return dv, next_hop

def print_distance_table(router_name, table, t, routers):
    print(f"Distance Table of router {router_name} at t={t}:")
    vias = sorted(table.keys())
    dests = sorted([d for d in routers if d != router_name])
    print("     " + "    ".join(dests))
    for via in vias:
        row = f"{via}    "
        for dest in dests:
            val = table[via].get(dest, INF)
            row += f"{val if val != INF else 'INF'}    "
        print(row.strip())
    print()

def print_routing_table(router_name, dv, next_hop):
    print(f"Routing Table of router {router_name}:")
    for dest in sorted(dv.keys()):
        if dest == router_name:
            continue
        print(f"{dest},{next_hop[dest]},{dv[dest] if dv[dest] != INF else 'INF'}")
    print()

def distance_vector_round(routers, graph, tables):
    updated = False
    new_tables = {}
    for router in routers:
        new_table = {}
        neighbors = graph[router]
        for via in neighbors:
            new_table[via] = {}
            dv_via, _ = compute_distance_vector(tables[via], routers)
            for dest in routers:
                if dest == router:
                    new_table[via][dest] = 0
                elif dest == via:
                    new_table[via][dest] = neighbors[via]
                else:
                    new_table[via][dest] = neighbors[via] + dv_via.get(dest, INF)
        if new_table != tables[router]:
            updated = True
        new_tables[router] = new_table
    return new_tables, updated

def apply_updates(graph, update_edges):
    for src, dst, cost in update_edges:
        if cost == -1:
            graph[src].pop(dst, None)
            graph[dst].pop(src, None)
        else:
            graph.setdefault(src, {})[dst] = cost
            graph.setdefault(dst, {})[src] = cost

def main():
    routers, topology, updates = read_input()
    graph = build_graph(routers, topology)
    tables = {r: initialize_distance_table(r, routers, graph) for r in routers}
    t = 0
    round_num = 0

    while True:
        while True:
            for r in routers:
                print_distance_table(r, tables[r], t, routers)
            tables, updated = distance_vector_round(routers, graph, tables)
            if not updated:
                break
            t += 1
        for r in routers:
            dv, nh = compute_distance_vector(tables[r], routers)
            print_routing_table(r, dv, nh)

        if round_num < len(updates):
            apply_updates(graph, updates[round_num])
            tables = {r: initialize_distance_table(r, routers, graph, tables) for r in routers}
            round_num += 1
            t += 1
        else:
            break

if __name__ == "__main__":
    main()

